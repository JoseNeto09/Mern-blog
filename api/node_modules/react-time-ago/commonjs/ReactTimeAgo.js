"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _javascriptTimeAgo = _interopRequireDefault(require("javascript-time-ago"));

var _getVerboseDateFormatter = _interopRequireDefault(require("./helpers/getVerboseDateFormatter.js"));

var _date = require("./helpers/date.js");

var _getTimeAgo = _interopRequireDefault(require("./helpers/getTimeAgo.js"));

var _Updater = _interopRequireDefault(require("./Updater.js"));

var _Time = _interopRequireDefault(require("./Time.js"));

var _PropTypes = require("./PropTypes.js");

var _excluded = ["date", "future", "timeStyle", "round", "minTimeLeft", "tooltip", "component", "container", "wrapperComponent", "wrapperProps", "locale", "locales", "formatVerboseDate", "verboseDateFormat", "updateInterval", "tick", "now", "timeOffset", "polyfill"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ReactTimeAgo(_ref) {
  var date = _ref.date,
      future = _ref.future,
      timeStyle = _ref.timeStyle,
      round = _ref.round,
      minTimeLeft = _ref.minTimeLeft,
      tooltip = _ref.tooltip,
      Component = _ref.component,
      container = _ref.container,
      wrapperComponent = _ref.wrapperComponent,
      wrapperProps = _ref.wrapperProps,
      locale = _ref.locale,
      locales = _ref.locales,
      formatVerboseDate = _ref.formatVerboseDate,
      verboseDateFormat = _ref.verboseDateFormat,
      updateInterval = _ref.updateInterval,
      tick = _ref.tick,
      nowProperty = _ref.now,
      timeOffset = _ref.timeOffset,
      polyfill = _ref.polyfill,
      rest = _objectWithoutProperties(_ref, _excluded);

  // Get the list of preferred locales.
  var preferredLocales = (0, _react.useMemo)(function () {
    // Convert `locale` to `locales`.
    if (locale) {
      locales = [locale];
    } // Add `javascript-time-ago` default locale.


    return locales.concat(_javascriptTimeAgo["default"].getDefaultLocale());
  }, [locale, locales]); // Create `javascript-time-ago` formatter instance.

  var timeAgo = (0, _react.useMemo)(function () {
    return (0, _getTimeAgo["default"])(preferredLocales, {
      polyfill: polyfill
    });
  }, [preferredLocales, polyfill]); // The date or timestamp that was passed.
  // Convert timestamp to `Date`.

  date = (0, _react.useMemo)(function () {
    return (0, _date.getDate)(date);
  }, [date]); // Formats the `date`.

  var formatDate = (0, _react.useCallback)(function () {
    var now = (nowProperty || Date.now()) - timeOffset;
    var stopUpdates;

    if (future) {
      if (now >= date.getTime()) {
        now = date.getTime();
        stopUpdates = true;
      }
    }

    if (minTimeLeft !== undefined) {
      var maxNow = date.getTime() - minTimeLeft * 1000;

      if (now > maxNow) {
        now = maxNow;
        stopUpdates = true;
      }
    }

    var _timeAgo$format = timeAgo.format(date, timeStyle, {
      getTimeToNextUpdate: true,
      now: now,
      future: future,
      round: round
    }),
        _timeAgo$format2 = _slicedToArray(_timeAgo$format, 2),
        formattedDate = _timeAgo$format2[0],
        timeToNextUpdate = _timeAgo$format2[1];

    if (stopUpdates) {
      timeToNextUpdate = INFINITY;
    } else {
      // Legacy compatibility: there used to be an `updateInterval` property.
      // That was before `getTimeToNextUpdate` feature was introduced in `javascript-time-ago`.
      // A default interval of one minute is introduced because
      // `getTimeToNextUpdate` feature may theoretically return `undefined`.
      timeToNextUpdate = updateInterval || timeToNextUpdate || 60 * 1000; // A minute by default.
    }

    return [formattedDate, now + timeToNextUpdate];
  }, [date, future, timeStyle, updateInterval, round, minTimeLeft, timeAgo, nowProperty]);
  var formatDateRef = (0, _react.useRef)();
  formatDateRef.current = formatDate;

  var _useMemo = (0, _react.useMemo)(formatDate, []),
      _useMemo2 = _slicedToArray(_useMemo, 2),
      _formattedDate = _useMemo2[0],
      _nextUpdateTime = _useMemo2[1];

  var _useState = (0, _react.useState)(_formattedDate),
      _useState2 = _slicedToArray(_useState, 2),
      formattedDate = _useState2[0],
      setFormattedDate = _useState2[1];

  var updater = (0, _react.useRef)();
  (0, _react.useEffect)(function () {
    if (tick) {
      updater.current = _Updater["default"].add({
        getNextValue: function getNextValue() {
          return formatDateRef.current();
        },
        setValue: setFormattedDate,
        nextUpdateTime: _nextUpdateTime
      });
      return function () {
        return updater.current.stop();
      };
    }
  }, [tick]);
  (0, _react.useEffect)(function () {
    if (updater.current) {
      updater.current.forceUpdate();
    } else {
      var _formatDate = formatDate(),
          _formatDate2 = _slicedToArray(_formatDate, 1),
          _formattedDate2 = _formatDate2[0];

      setFormattedDate(_formattedDate2);
    }
  }, [formatDate]); // Create verbose date formatter for the tooltip text.

  var verboseDateFormatter = (0, _react.useMemo)(function () {
    return (0, _getVerboseDateFormatter["default"])(preferredLocales, verboseDateFormat);
  }, [preferredLocales, verboseDateFormat]); // Format verbose date for the tooltip.

  var verboseDate = (0, _react.useMemo)(function () {
    if (formatVerboseDate) {
      return formatVerboseDate(date);
    }

    return verboseDateFormatter(date);
  }, [date, formatVerboseDate, verboseDateFormatter]);

  var result = /*#__PURE__*/_react["default"].createElement(Component, _extends({
    date: date,
    verboseDate: verboseDate,
    tooltip: tooltip
  }, rest), formattedDate);

  var WrapperComponent = wrapperComponent || container;

  if (WrapperComponent) {
    return /*#__PURE__*/_react["default"].createElement(WrapperComponent, _extends({}, wrapperProps, {
      verboseDate: verboseDate
    }), result);
  }

  return result;
}

ReactTimeAgo.propTypes = {
  // The `date` or `timestamp`.
  // E.g. `new Date()` or `1355972400000`.
  date: _propTypes["default"].oneOfType([_propTypes["default"].instanceOf(Date), _propTypes["default"].number]).isRequired,
  // Preferred locale.
  // Is 'en' by default.
  // E.g. 'ru-RU'.
  locale: _propTypes["default"].string,
  // Alternatively to `locale`, one could pass `locales`:
  // A list of preferred locales (ordered).
  // Will choose the first supported locale from the list.
  // E.g. `['ru-RU', 'en-GB']`.
  locales: _propTypes["default"].arrayOf(_propTypes["default"].string),
  // If set to `true`, then will stop at "zero point"
  // when going from future dates to past dates.
  // In other words, even if the `date` has passed,
  // it will still render as if `date` is `now`.
  future: _propTypes["default"].bool,
  // Date/time formatting style.
  // See `javascript-time-ago` docs on "Styles" for more info.
  // E.g. 'round', 'round-minute', 'twitter', 'twitter-first-minute'.
  timeStyle: _PropTypes.style,
  // `round` parameter of `javascript-time-ago`.
  // See `javascript-time-ago` docs on "Rounding" for more info.
  // Examples: "round", "floor".
  round: _propTypes["default"].string,
  // If specified, the time won't "tick" past this threshold (in seconds).
  // For example, if `minTimeLeft` is `60 * 60`
  // then the time won't "tick" past "in 1 hour".
  minTimeLeft: _propTypes["default"].number,
  // A React component to render the relative time label.
  // Receives properties:
  // * date: Date — The date.
  // * verboseDate: string — Formatted verbose date.
  // * tooltip: boolean — The `tooltip` property of `<ReactTimeAgo/>` component.
  // * children: string — The relative time label.
  // * All "unknown" properties that have been passed to `<ReactTimeAgo/>` are passed through to this component.
  component: _propTypes["default"].elementType.isRequired,
  // Whether to use HTML `tooltip` attribute to show a verbose date tooltip.
  // Is `true` by default.
  // Can be set to `false` to disable the native HTML `tooltip`.
  tooltip: _propTypes["default"].bool.isRequired,
  // Verbose date formatter.
  // By default it's `(date) => new Intl.DateTimeFormat(locale, {…}).format(date)`.
  formatVerboseDate: _propTypes["default"].func,
  // `Intl.DateTimeFormat` format for formatting verbose date.
  // See `Intl.DateTimeFormat` docs for more info.
  verboseDateFormat: _propTypes["default"].object,
  // (deprecated)
  // How often the component refreshes itself.
  // Instead, consider using `getNextTimeToUpdate()` feature
  // of `javascript-time-ago` styles.
  updateInterval: _propTypes["default"].oneOfType([_propTypes["default"].number, _propTypes["default"].arrayOf(_propTypes["default"].shape({
    threshold: _propTypes["default"].number,
    interval: _propTypes["default"].number.isRequired
  }))]),
  // (deprecated).
  // Set to `false` to disable automatic refresh of the component.
  // Is `true` by default.
  // I guess no one actually turns that off.
  tick: _propTypes["default"].bool,
  // Allows setting a custom baseline for relative time measurement.
  // https://gitlab.com/catamphetamine/react-time-ago/-/issues/4
  now: _propTypes["default"].number,
  // Allows offsetting the `date` by an arbitrary amount of milliseconds.
  // https://gitlab.com/catamphetamine/react-time-ago/-/issues/4
  timeOffset: _propTypes["default"].number,
  // Pass `false` to use native `Intl.RelativeTimeFormat` / `Intl.PluralRules`
  // instead of the polyfilled ones in `javascript-time-ago`.
  polyfill: _propTypes["default"].bool,
  // (advanced)
  // A React Component to wrap the resulting `<time/>` React Element.
  // Receives `verboseDate` and `children` properties.
  // Also receives `wrapperProps`, if they're passed.
  // `verboseDate` can be used for displaying verbose date label
  // in an "on mouse over" (or "on touch") tooltip.
  // See the "Tooltip" readme section for more info.
  // Another example could be having `wrapperComponent`
  // being rerendered every time the component refreshes itself.
  wrapperComponent: _propTypes["default"].elementType,
  // Custom `props` passed to `wrapperComponent`.
  wrapperProps: _propTypes["default"].object
};
ReactTimeAgo.defaultProps = {
  // No preferred locales.
  locales: [],
  // Use a `<time/>` tag by default.
  component: _Time["default"],
  // Use HTML `tooltip` attribute to show a verbose date tooltip.
  tooltip: true,
  // `Intl.DateTimeFormat` for verbose date.
  // Example: "Thursday, December 20, 2012, 7:00:00 AM GMT+4"
  verboseDateFormat: {
    weekday: 'long',
    day: 'numeric',
    month: 'long',
    year: 'numeric',
    hour: 'numeric',
    minute: '2-digit',
    second: '2-digit' // timeZoneName: 'short'

  },
  // Automatically refreshes itself.
  tick: true,
  // No time offset.
  timeOffset: 0
}; // The component schedules a next refresh every time it renders.
// There's no need to rerender this component unless its props change.

ReactTimeAgo = /*#__PURE__*/_react["default"].memo(ReactTimeAgo);
var _default = ReactTimeAgo; // A thousand years is practically a metaphor for "infinity"
// in the context of this component.

exports["default"] = _default;
var YEAR = 365 * 24 * 60 * 60 * 1000;
var INFINITY = 1000 * YEAR;
//# sourceMappingURL=ReactTimeAgo.js.map